import logging
import os
import tempfile
import fitz  # PyMuPDF
from paddleocr import PaddleOCR, PPStructureV3
import numpy as np
from typing import Optional, List

# Global variable to hold the initialized OCR engine
structure_engine = None
current_ocr_config = {}

def get_structure_engine(lang: str = 'ch'):
    """
    Initializes or re-initializes the PPStructureV3 engine with a configured OCR system.
    """
    global structure_engine, current_ocr_config
    
    new_config = {'lang': lang}
    
    if structure_engine is None or current_ocr_config != new_config:
        logging.info(f"Initializing PPStructureV3 with underlying OCR lang: {lang}")
        
        # 1. Initialize the underlying OCR engine with the desired language
        ocr_engine = PaddleOCR(use_angle_cls=True, lang=lang)
        
        # 2. Initialize PPStructureV3 and pass the configured OCR engine
        # Note: PPStructureV3 does not take 'lang' or 'layout' directly.
        structure_engine = PPStructureV3(show_log=False, text_system=ocr_engine)
        
        current_ocr_config = new_config
    return structure_engine

def is_page_blank(pix: fitz.Pixmap, threshold: float = 1.0) -> bool:
    """
    Check if a page image is mostly blank.
    """
    img_array = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, -1)
    
    if img_array.shape[2] > 1:
        gray_img = np.mean(img_array, axis=2)
    else:
        gray_img = img_array.squeeze()

    non_white_pixels = np.sum(gray_img < 250)
    total_pixels = pix.width * pix.height
    non_white_percentage = (non_white_pixels / total_pixels) * 100
    
    return non_white_percentage < threshold

def is_pdf_vertical(pdf_path: str, vertical_lang: str) -> bool:
    """
    Checks if the PDF has a predominantly vertical text layout by analyzing the first content page.
    """
    doc = None
    try:
        doc = fitz.open(pdf_path)
        first_content_page_pix = None
        for page in doc:
            pix = page.get_pixmap()
            if not is_page_blank(pix):
                first_content_page_pix = pix
                break
        
        if first_content_page_pix is None:
            logging.warning("PDF appears to be blank or has no detectable content.")
            return False

        print("🔍 Detecting layout and orientation with PP-Structure...")
        return is_vertical_from_layout(first_content_page_pix, vertical_lang)

    except Exception as e:
        logging.error(f"Error in vertical PDF detection: {e}", exc_info=True)
        return False
    finally:
        if doc:
            doc.close()

def process_vertical_pdf(pdf_path: str, vertical_lang: str, page_limit: Optional[int] = None) -> Optional[str]:
    """
    Handles the end-to-end OCR and text extraction for a vertical PDF.
    """
    doc = None
    try:
        doc = fitz.open(pdf_path)
        
        page_images = []
        pages_to_process = doc if page_limit is None else doc.pages(stop=page_limit)
        for page in pages_to_process:
            page_images.append(page.get_pixmap())
        
        print("📋 Extracting text from all pages of vertical PDF...")
        full_text = extract_text_from_images_paddleocr(page_images, vertical_lang)
        return full_text

    except Exception as e:
        logging.error(f"Error in vertical PDF processing: {e}", exc_info=True)
        return None
    finally:
        if doc:
            doc.close()

def is_vertical_from_layout(pix: fitz.Pixmap, lang: str) -> bool:
    """
    Detects if the text layout is predominantly vertical by analyzing the layout regions.
    """
    engine = get_structure_engine(lang=lang)
    
    img_array = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, 3)

    result = engine(img_array)
    logging.info(f"PP-Structure raw result for layout detection: {result}")

    if not result:
        return False

    aspect_ratios = []
    for region in result:
        if region['type'] == 'text':
            bbox = region['bbox']
            height = bbox[3] - bbox[1]
            width = bbox[2] - bbox[0]
            if width > 0:
                aspect_ratios.append(height / width)
            
    if not aspect_ratios:
        return False
        
    median_ratio = np.median(aspect_ratios)
    logging.info(f"Median aspect ratio of text boxes: {median_ratio:.2f}")
    
    return median_ratio > 1.5 # Use a stricter threshold for layout blocks

def extract_text_from_images_paddleocr(images: List[fitz.Pixmap], lang: str) -> str:
    """
    Extracts and sorts text from a list of page images using PP-Structure.
    """
    engine = get_structure_engine(lang=lang)
    full_doc_text = []

    for pix in images:
        if is_page_blank(pix):
            continue

        img_array = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, 3)
        result = engine(img_array)

        if not result:
            continue

        text_regions = [res for res in result if res['type'] == 'text' and 'res' in res]
        
        # Sort regions by right-to-left, then top-to-bottom
        text_regions.sort(key=lambda r: (-r['bbox'][0], r['bbox'][1]))
        
        page_text_parts = []
        for region in text_regions:
            for line in region['res']:
                page_text_parts.append(line['text'])
        
        page_text = "\n".join(page_text_parts)
        full_doc_text.append(page_text)

    return "\n\n---\n\n".join(full_doc_text)