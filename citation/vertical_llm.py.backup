import re
import dspy
from typing import Dict, List, Tuple, Optional
from .model import CitationLLM


class VerticalCitationExtraction(dspy.Signature):
    """Extract citation information from traditional Chinese/Japanese vertical text books"""
    
    text = dspy.InputField(desc="Traditional Chinese or Japanese vertical text content")
    
    # Core fields
    title = dspy.OutputField(desc="Complete book title in traditional characters")
    author = dspy.OutputField(desc="Author name with dynasty and role indicators (e.g., '【明】王陽明撰, 朱熹注')")
    publisher = dspy.OutputField(desc="Publisher name in traditional characters")
    publication_year = dspy.OutputField(desc="Publication year (may be in Chinese numerals or era format)")
    original_year = dspy.OutputField(desc="Original writing year if different from publication")
    place = dspy.OutputField(desc="Publication place")
    
    # Additional metadata
    series = dspy.OutputField(desc="Book series or collection name if mentioned")
    volume = dspy.OutputField(desc="Volume number if part of multi-volume work")
    subtitle = dspy.OutputField(desc="Subtitle if present")
    translator = dspy.OutputField(desc="Translator name if translation work")
    edition = dspy.OutputField(desc="Edition information")
    commentary_author = dspy.OutputField(desc="Commentary author if different from main author")
    original_title = dspy.OutputField(desc="Original title if this is a commentary or annotation")


class VerticalCitationLLM(CitationLLM):
    """Specialized LLM for vertical Traditional Chinese/Japanese citations"""
    
    def __init__(self, model_name="ollama/qwen3"):
        super().__init__(model_name)
        self.vertical_extractor = dspy.Predict(VerticalCitationExtraction)
    
    def extract_vertical_citation(self, text: str, doc_type: str = "book") -> Dict:
        """Extract citation using vertical text patterns"""
        try:
            result = self.vertical_extractor(text=text)
            
            # Convert raw result to dictionary
            citation_info = {
                "title": result.title,
                "publisher": result.publisher,
                "place": result.place,
                "series": result.series,
                "volume": result.volume,
                "subtitle": result.subtitle, 
                "translator": result.translator,
                "edition": result.edition,
                "commentary_author": result.commentary_author,
                "original_title": result.original_title,
            }
            
            # Process authors with dynasty and role parsing
            if result.author:
                authors_info = self.parse_multiple_authors(result.author)
                citation_info["author"] = authors_info
            
            # Convert years
            if result.publication_year:
                citation_info["year"] = self.convert_chinese_japanese_year(result.publication_year)
            if result.original_year:
                citation_info["original_year"] = self.convert_chinese_japanese_year(result.original_year)
            
            # Clean up empty fields
            citation_info = {k: v for k, v in citation_info.items() if v and str(v).strip()}
            
            return citation_info
            
        except Exception as e:
            print(f"❌ Vertical citation extraction failed: {e}")
            # Fallback to regular LLM
            return super().extract_citation_from_text(text, doc_type)
    
    def parse_multiple_authors(self, author_string: str) -> str:
        """Parse multiple authors with dynasty and role indicators"""
        if not author_string:
            return ""
        
        # Split by common separators
        author_parts = re.split(r'[,，;；]', author_string)
        parsed_authors = []
        
        for part in author_parts:
            part = part.strip()
            if not part:
                continue
                
            dynasty, author_name, role = self.extract_dynasty_author_role(part)
            
            # Format with role indicators
            author_str = author_name
            if dynasty:
                author_str = f"【{dynasty}】{author_str}"
            if role:
                author_str = f"{author_str}{role}"
                
            parsed_authors.append(author_str)
        
        return ", ".join(parsed_authors)
    
    def extract_dynasty_author_role(self, text: str) -> Tuple[str, str, str]:
        """Extract dynasty, author name, and role from text like '【明】王陽明撰'"""
        dynasty = ""
        author_name = ""
        role = ""
        
        # Extract dynasty from various bracket styles
        dynasty_pattern = r'[【\[［〔\(]([^】\]］〕\)]*)[】\]］〕\)]'
        dynasty_match = re.search(dynasty_pattern, text)
        if dynasty_match:
            dynasty = dynasty_match.group(1)
            text = re.sub(dynasty_pattern, '', text)
        
        # Extract role indicators (撰, 著, 注, 編, etc.)
        role_pattern = r'([撰著注註編輯譯序跋])$'
        role_match = re.search(role_pattern, text)
        if role_match:
            role = role_match.group(1)
            text = re.sub(role_pattern, '', text)
        
        # Remaining text is the author name
        author_name = text.strip()
        
        return dynasty, author_name, role
    
    def convert_chinese_japanese_year(self, year_str: str) -> str:
        """Convert Chinese/Japanese year formats to Arabic numerals"""
        if not year_str or not isinstance(year_str, str):
            return ""
        
        year_str = year_str.strip()
        
        dynasty_pattern = r"[【\\[［〔\\(]([^】\\]］〕\\)]*)[】\\]］〕\\)]"
        if re.match(r'^\d{4}$', year_str):
            return year_str
        
        try:
            # Chinese numerals to Arabic mapping
            chinese_nums = {
                '〇': '0', '零': '0', '一': '1', '二': '2', '三': '3', '四': '4',
                '五': '5', '六': '6', '七': '7', '八': '8', '九': '9'
            }
            
            # Handle format like 一九六二年
            if re.match(r'^[〇零一二三四五六七八九]{4}年?$', year_str):
                converted = year_str.replace('年', '')
                for chinese, arabic in chinese_nums.items():
                    converted = converted.replace(chinese, arabic)
                return converted
            
            # Handle Taiwan 民國 format
            minguo_match = re.match(r'民國([〇零一二三四五六七八九十百]{1,3})年?', year_str)
            if minguo_match:
                minguo_year = minguo_match.group(1)
                minguo_arabic = self.convert_chinese_number_to_arabic(minguo_year)
                return str(1911 + int(minguo_arabic))
            
            # Handle Japanese era formats
            japanese_eras = {
                '明治': 1868, '大正': 1912, '昭和': 1926, '平成': 1989, '令和': 2019
            }
            
            for era, base_year in japanese_eras.items():
                era_pattern = f'{era}([〇零一二三四五六七八九十百]{{1,3}})年?'
                era_match = re.match(era_pattern, year_str)
                if era_match:
                    era_year = era_match.group(1)
                    era_arabic = self.convert_chinese_number_to_arabic(era_year)
                    return str(base_year + int(era_arabic) - 1)
            
            return year_str  # Return original if conversion fails
            
        except Exception as e:
            print(f"⚠️ Year conversion failed for '{year_str}': {e}")
            return year_str
    
    def convert_chinese_number_to_arabic(self, chinese_num: str) -> str:
        """Convert Chinese number to Arabic (handles up to hundreds)"""
        if not chinese_num:
            return "0"
        
        # Simple mapping for basic numbers
        chinese_nums = {
            '〇': 0, '零': 0, '一': 1, '二': 2, '三': 3, '四': 4,
            '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10
        }
        
        # Handle simple cases first
        if chinese_num in chinese_nums:
            return str(chinese_nums[chinese_num])
        
        # Handle compound numbers like 十五, 二十三, etc.
        result = 0
        current = 0
        
        for char in chinese_num:
            if char == '十':
                if current == 0:
                    current = 1
                result += current * 10
                current = 0
            elif char == '百':
                result += current * 100
                current = 0
            elif char in chinese_nums:
                current = chinese_nums[char]
        
        result += current
        return str(result)
